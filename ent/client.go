// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"github.com/google/uuid"
	"github.com/shinobistack/gokakashi/ent/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/shinobistack/gokakashi/ent/agentlabels"
	"github.com/shinobistack/gokakashi/ent/agents"
	"github.com/shinobistack/gokakashi/ent/agentsv2"
	"github.com/shinobistack/gokakashi/ent/agenttasks"
	"github.com/shinobistack/gokakashi/ent/integrations"
	"github.com/shinobistack/gokakashi/ent/integrationtype"
	"github.com/shinobistack/gokakashi/ent/policies"
	"github.com/shinobistack/gokakashi/ent/policylabels"
	"github.com/shinobistack/gokakashi/ent/scanlabels"
	"github.com/shinobistack/gokakashi/ent/scannotify"
	"github.com/shinobistack/gokakashi/ent/scans"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// AgentLabels is the client for interacting with the AgentLabels builders.
	AgentLabels *AgentLabelsClient
	// AgentTasks is the client for interacting with the AgentTasks builders.
	AgentTasks *AgentTasksClient
	// Agents is the client for interacting with the Agents builders.
	Agents *AgentsClient
	// AgentsV2 is the client for interacting with the AgentsV2 builders.
	AgentsV2 *AgentsV2Client
	// IntegrationType is the client for interacting with the IntegrationType builders.
	IntegrationType *IntegrationTypeClient
	// Integrations is the client for interacting with the Integrations builders.
	Integrations *IntegrationsClient
	// Policies is the client for interacting with the Policies builders.
	Policies *PoliciesClient
	// PolicyLabels is the client for interacting with the PolicyLabels builders.
	PolicyLabels *PolicyLabelsClient
	// ScanLabels is the client for interacting with the ScanLabels builders.
	ScanLabels *ScanLabelsClient
	// ScanNotify is the client for interacting with the ScanNotify builders.
	ScanNotify *ScanNotifyClient
	// Scans is the client for interacting with the Scans builders.
	Scans *ScansClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.AgentLabels = NewAgentLabelsClient(c.config)
	c.AgentTasks = NewAgentTasksClient(c.config)
	c.Agents = NewAgentsClient(c.config)
	c.AgentsV2 = NewAgentsV2Client(c.config)
	c.IntegrationType = NewIntegrationTypeClient(c.config)
	c.Integrations = NewIntegrationsClient(c.config)
	c.Policies = NewPoliciesClient(c.config)
	c.PolicyLabels = NewPolicyLabelsClient(c.config)
	c.ScanLabels = NewScanLabelsClient(c.config)
	c.ScanNotify = NewScanNotifyClient(c.config)
	c.Scans = NewScansClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:             ctx,
		config:          cfg,
		AgentLabels:     NewAgentLabelsClient(cfg),
		AgentTasks:      NewAgentTasksClient(cfg),
		Agents:          NewAgentsClient(cfg),
		AgentsV2:        NewAgentsV2Client(cfg),
		IntegrationType: NewIntegrationTypeClient(cfg),
		Integrations:    NewIntegrationsClient(cfg),
		Policies:        NewPoliciesClient(cfg),
		PolicyLabels:    NewPolicyLabelsClient(cfg),
		ScanLabels:      NewScanLabelsClient(cfg),
		ScanNotify:      NewScanNotifyClient(cfg),
		Scans:           NewScansClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:             ctx,
		config:          cfg,
		AgentLabels:     NewAgentLabelsClient(cfg),
		AgentTasks:      NewAgentTasksClient(cfg),
		Agents:          NewAgentsClient(cfg),
		AgentsV2:        NewAgentsV2Client(cfg),
		IntegrationType: NewIntegrationTypeClient(cfg),
		Integrations:    NewIntegrationsClient(cfg),
		Policies:        NewPoliciesClient(cfg),
		PolicyLabels:    NewPolicyLabelsClient(cfg),
		ScanLabels:      NewScanLabelsClient(cfg),
		ScanNotify:      NewScanNotifyClient(cfg),
		Scans:           NewScansClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		AgentLabels.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.AgentLabels, c.AgentTasks, c.Agents, c.AgentsV2, c.IntegrationType,
		c.Integrations, c.Policies, c.PolicyLabels, c.ScanLabels, c.ScanNotify,
		c.Scans,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.AgentLabels, c.AgentTasks, c.Agents, c.AgentsV2, c.IntegrationType,
		c.Integrations, c.Policies, c.PolicyLabels, c.ScanLabels, c.ScanNotify,
		c.Scans,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *AgentLabelsMutation:
		return c.AgentLabels.mutate(ctx, m)
	case *AgentTasksMutation:
		return c.AgentTasks.mutate(ctx, m)
	case *AgentsMutation:
		return c.Agents.mutate(ctx, m)
	case *AgentsV2Mutation:
		return c.AgentsV2.mutate(ctx, m)
	case *IntegrationTypeMutation:
		return c.IntegrationType.mutate(ctx, m)
	case *IntegrationsMutation:
		return c.Integrations.mutate(ctx, m)
	case *PoliciesMutation:
		return c.Policies.mutate(ctx, m)
	case *PolicyLabelsMutation:
		return c.PolicyLabels.mutate(ctx, m)
	case *ScanLabelsMutation:
		return c.ScanLabels.mutate(ctx, m)
	case *ScanNotifyMutation:
		return c.ScanNotify.mutate(ctx, m)
	case *ScansMutation:
		return c.Scans.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// AgentLabelsClient is a client for the AgentLabels schema.
type AgentLabelsClient struct {
	config
}

// NewAgentLabelsClient returns a client for the AgentLabels from the given config.
func NewAgentLabelsClient(c config) *AgentLabelsClient {
	return &AgentLabelsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `agentlabels.Hooks(f(g(h())))`.
func (c *AgentLabelsClient) Use(hooks ...Hook) {
	c.hooks.AgentLabels = append(c.hooks.AgentLabels, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `agentlabels.Intercept(f(g(h())))`.
func (c *AgentLabelsClient) Intercept(interceptors ...Interceptor) {
	c.inters.AgentLabels = append(c.inters.AgentLabels, interceptors...)
}

// Create returns a builder for creating a AgentLabels entity.
func (c *AgentLabelsClient) Create() *AgentLabelsCreate {
	mutation := newAgentLabelsMutation(c.config, OpCreate)
	return &AgentLabelsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AgentLabels entities.
func (c *AgentLabelsClient) CreateBulk(builders ...*AgentLabelsCreate) *AgentLabelsCreateBulk {
	return &AgentLabelsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AgentLabelsClient) MapCreateBulk(slice any, setFunc func(*AgentLabelsCreate, int)) *AgentLabelsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AgentLabelsCreateBulk{err: fmt.Errorf("calling to AgentLabelsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AgentLabelsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AgentLabelsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AgentLabels.
func (c *AgentLabelsClient) Update() *AgentLabelsUpdate {
	mutation := newAgentLabelsMutation(c.config, OpUpdate)
	return &AgentLabelsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AgentLabelsClient) UpdateOne(al *AgentLabels) *AgentLabelsUpdateOne {
	mutation := newAgentLabelsMutation(c.config, OpUpdateOne, withAgentLabels(al))
	return &AgentLabelsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AgentLabelsClient) UpdateOneID(id int) *AgentLabelsUpdateOne {
	mutation := newAgentLabelsMutation(c.config, OpUpdateOne, withAgentLabelsID(id))
	return &AgentLabelsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AgentLabels.
func (c *AgentLabelsClient) Delete() *AgentLabelsDelete {
	mutation := newAgentLabelsMutation(c.config, OpDelete)
	return &AgentLabelsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AgentLabelsClient) DeleteOne(al *AgentLabels) *AgentLabelsDeleteOne {
	return c.DeleteOneID(al.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AgentLabelsClient) DeleteOneID(id int) *AgentLabelsDeleteOne {
	builder := c.Delete().Where(agentlabels.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AgentLabelsDeleteOne{builder}
}

// Query returns a query builder for AgentLabels.
func (c *AgentLabelsClient) Query() *AgentLabelsQuery {
	return &AgentLabelsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAgentLabels},
		inters: c.Interceptors(),
	}
}

// Get returns a AgentLabels entity by its id.
func (c *AgentLabelsClient) Get(ctx context.Context, id int) (*AgentLabels, error) {
	return c.Query().Where(agentlabels.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AgentLabelsClient) GetX(ctx context.Context, id int) *AgentLabels {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAgents queries the agents edge of a AgentLabels.
func (c *AgentLabelsClient) QueryAgents(al *AgentLabels) *AgentsQuery {
	query := (&AgentsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := al.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(agentlabels.Table, agentlabels.FieldID, id),
			sqlgraph.To(agents.Table, agents.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, agentlabels.AgentsTable, agentlabels.AgentsColumn),
		)
		fromV = sqlgraph.Neighbors(al.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AgentLabelsClient) Hooks() []Hook {
	return c.hooks.AgentLabels
}

// Interceptors returns the client interceptors.
func (c *AgentLabelsClient) Interceptors() []Interceptor {
	return c.inters.AgentLabels
}

func (c *AgentLabelsClient) mutate(ctx context.Context, m *AgentLabelsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AgentLabelsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AgentLabelsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AgentLabelsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AgentLabelsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AgentLabels mutation op: %q", m.Op())
	}
}

// AgentTasksClient is a client for the AgentTasks schema.
type AgentTasksClient struct {
	config
}

// NewAgentTasksClient returns a client for the AgentTasks from the given config.
func NewAgentTasksClient(c config) *AgentTasksClient {
	return &AgentTasksClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `agenttasks.Hooks(f(g(h())))`.
func (c *AgentTasksClient) Use(hooks ...Hook) {
	c.hooks.AgentTasks = append(c.hooks.AgentTasks, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `agenttasks.Intercept(f(g(h())))`.
func (c *AgentTasksClient) Intercept(interceptors ...Interceptor) {
	c.inters.AgentTasks = append(c.inters.AgentTasks, interceptors...)
}

// Create returns a builder for creating a AgentTasks entity.
func (c *AgentTasksClient) Create() *AgentTasksCreate {
	mutation := newAgentTasksMutation(c.config, OpCreate)
	return &AgentTasksCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AgentTasks entities.
func (c *AgentTasksClient) CreateBulk(builders ...*AgentTasksCreate) *AgentTasksCreateBulk {
	return &AgentTasksCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AgentTasksClient) MapCreateBulk(slice any, setFunc func(*AgentTasksCreate, int)) *AgentTasksCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AgentTasksCreateBulk{err: fmt.Errorf("calling to AgentTasksClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AgentTasksCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AgentTasksCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AgentTasks.
func (c *AgentTasksClient) Update() *AgentTasksUpdate {
	mutation := newAgentTasksMutation(c.config, OpUpdate)
	return &AgentTasksUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AgentTasksClient) UpdateOne(at *AgentTasks) *AgentTasksUpdateOne {
	mutation := newAgentTasksMutation(c.config, OpUpdateOne, withAgentTasks(at))
	return &AgentTasksUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AgentTasksClient) UpdateOneID(id uuid.UUID) *AgentTasksUpdateOne {
	mutation := newAgentTasksMutation(c.config, OpUpdateOne, withAgentTasksID(id))
	return &AgentTasksUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AgentTasks.
func (c *AgentTasksClient) Delete() *AgentTasksDelete {
	mutation := newAgentTasksMutation(c.config, OpDelete)
	return &AgentTasksDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AgentTasksClient) DeleteOne(at *AgentTasks) *AgentTasksDeleteOne {
	return c.DeleteOneID(at.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AgentTasksClient) DeleteOneID(id uuid.UUID) *AgentTasksDeleteOne {
	builder := c.Delete().Where(agenttasks.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AgentTasksDeleteOne{builder}
}

// Query returns a query builder for AgentTasks.
func (c *AgentTasksClient) Query() *AgentTasksQuery {
	return &AgentTasksQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAgentTasks},
		inters: c.Interceptors(),
	}
}

// Get returns a AgentTasks entity by its id.
func (c *AgentTasksClient) Get(ctx context.Context, id uuid.UUID) (*AgentTasks, error) {
	return c.Query().Where(agenttasks.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AgentTasksClient) GetX(ctx context.Context, id uuid.UUID) *AgentTasks {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAgent queries the agent edge of a AgentTasks.
func (c *AgentTasksClient) QueryAgent(at *AgentTasks) *AgentsQuery {
	query := (&AgentsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := at.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(agenttasks.Table, agenttasks.FieldID, id),
			sqlgraph.To(agents.Table, agents.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, agenttasks.AgentTable, agenttasks.AgentColumn),
		)
		fromV = sqlgraph.Neighbors(at.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryScan queries the scan edge of a AgentTasks.
func (c *AgentTasksClient) QueryScan(at *AgentTasks) *ScansQuery {
	query := (&ScansClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := at.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(agenttasks.Table, agenttasks.FieldID, id),
			sqlgraph.To(scans.Table, scans.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, agenttasks.ScanTable, agenttasks.ScanColumn),
		)
		fromV = sqlgraph.Neighbors(at.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AgentTasksClient) Hooks() []Hook {
	return c.hooks.AgentTasks
}

// Interceptors returns the client interceptors.
func (c *AgentTasksClient) Interceptors() []Interceptor {
	return c.inters.AgentTasks
}

func (c *AgentTasksClient) mutate(ctx context.Context, m *AgentTasksMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AgentTasksCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AgentTasksUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AgentTasksUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AgentTasksDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AgentTasks mutation op: %q", m.Op())
	}
}

// AgentsClient is a client for the Agents schema.
type AgentsClient struct {
	config
}

// NewAgentsClient returns a client for the Agents from the given config.
func NewAgentsClient(c config) *AgentsClient {
	return &AgentsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `agents.Hooks(f(g(h())))`.
func (c *AgentsClient) Use(hooks ...Hook) {
	c.hooks.Agents = append(c.hooks.Agents, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `agents.Intercept(f(g(h())))`.
func (c *AgentsClient) Intercept(interceptors ...Interceptor) {
	c.inters.Agents = append(c.inters.Agents, interceptors...)
}

// Create returns a builder for creating a Agents entity.
func (c *AgentsClient) Create() *AgentsCreate {
	mutation := newAgentsMutation(c.config, OpCreate)
	return &AgentsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Agents entities.
func (c *AgentsClient) CreateBulk(builders ...*AgentsCreate) *AgentsCreateBulk {
	return &AgentsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AgentsClient) MapCreateBulk(slice any, setFunc func(*AgentsCreate, int)) *AgentsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AgentsCreateBulk{err: fmt.Errorf("calling to AgentsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AgentsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AgentsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Agents.
func (c *AgentsClient) Update() *AgentsUpdate {
	mutation := newAgentsMutation(c.config, OpUpdate)
	return &AgentsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AgentsClient) UpdateOne(a *Agents) *AgentsUpdateOne {
	mutation := newAgentsMutation(c.config, OpUpdateOne, withAgents(a))
	return &AgentsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AgentsClient) UpdateOneID(id int) *AgentsUpdateOne {
	mutation := newAgentsMutation(c.config, OpUpdateOne, withAgentsID(id))
	return &AgentsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Agents.
func (c *AgentsClient) Delete() *AgentsDelete {
	mutation := newAgentsMutation(c.config, OpDelete)
	return &AgentsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AgentsClient) DeleteOne(a *Agents) *AgentsDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AgentsClient) DeleteOneID(id int) *AgentsDeleteOne {
	builder := c.Delete().Where(agents.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AgentsDeleteOne{builder}
}

// Query returns a query builder for Agents.
func (c *AgentsClient) Query() *AgentsQuery {
	return &AgentsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAgents},
		inters: c.Interceptors(),
	}
}

// Get returns a Agents entity by its id.
func (c *AgentsClient) Get(ctx context.Context, id int) (*Agents, error) {
	return c.Query().Where(agents.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AgentsClient) GetX(ctx context.Context, id int) *Agents {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAgentTasks queries the agent_tasks edge of a Agents.
func (c *AgentsClient) QueryAgentTasks(a *Agents) *AgentTasksQuery {
	query := (&AgentTasksClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(agents.Table, agents.FieldID, id),
			sqlgraph.To(agenttasks.Table, agenttasks.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, agents.AgentTasksTable, agents.AgentTasksColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAgentLabels queries the agent_labels edge of a Agents.
func (c *AgentsClient) QueryAgentLabels(a *Agents) *AgentLabelsQuery {
	query := (&AgentLabelsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(agents.Table, agents.FieldID, id),
			sqlgraph.To(agentlabels.Table, agentlabels.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, agents.AgentLabelsTable, agents.AgentLabelsColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AgentsClient) Hooks() []Hook {
	return c.hooks.Agents
}

// Interceptors returns the client interceptors.
func (c *AgentsClient) Interceptors() []Interceptor {
	return c.inters.Agents
}

func (c *AgentsClient) mutate(ctx context.Context, m *AgentsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AgentsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AgentsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AgentsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AgentsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Agents mutation op: %q", m.Op())
	}
}

// AgentsV2Client is a client for the AgentsV2 schema.
type AgentsV2Client struct {
	config
}

// NewAgentsV2Client returns a client for the AgentsV2 from the given config.
func NewAgentsV2Client(c config) *AgentsV2Client {
	return &AgentsV2Client{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `agentsv2.Hooks(f(g(h())))`.
func (c *AgentsV2Client) Use(hooks ...Hook) {
	c.hooks.AgentsV2 = append(c.hooks.AgentsV2, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `agentsv2.Intercept(f(g(h())))`.
func (c *AgentsV2Client) Intercept(interceptors ...Interceptor) {
	c.inters.AgentsV2 = append(c.inters.AgentsV2, interceptors...)
}

// Create returns a builder for creating a AgentsV2 entity.
func (c *AgentsV2Client) Create() *AgentsV2Create {
	mutation := newAgentsV2Mutation(c.config, OpCreate)
	return &AgentsV2Create{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AgentsV2 entities.
func (c *AgentsV2Client) CreateBulk(builders ...*AgentsV2Create) *AgentsV2CreateBulk {
	return &AgentsV2CreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AgentsV2Client) MapCreateBulk(slice any, setFunc func(*AgentsV2Create, int)) *AgentsV2CreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AgentsV2CreateBulk{err: fmt.Errorf("calling to AgentsV2Client.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AgentsV2Create, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AgentsV2CreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AgentsV2.
func (c *AgentsV2Client) Update() *AgentsV2Update {
	mutation := newAgentsV2Mutation(c.config, OpUpdate)
	return &AgentsV2Update{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AgentsV2Client) UpdateOne(a *AgentsV2) *AgentsV2UpdateOne {
	mutation := newAgentsV2Mutation(c.config, OpUpdateOne, withAgentsV2(a))
	return &AgentsV2UpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AgentsV2Client) UpdateOneID(id uuid.UUID) *AgentsV2UpdateOne {
	mutation := newAgentsV2Mutation(c.config, OpUpdateOne, withAgentsV2ID(id))
	return &AgentsV2UpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AgentsV2.
func (c *AgentsV2Client) Delete() *AgentsV2Delete {
	mutation := newAgentsV2Mutation(c.config, OpDelete)
	return &AgentsV2Delete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AgentsV2Client) DeleteOne(a *AgentsV2) *AgentsV2DeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AgentsV2Client) DeleteOneID(id uuid.UUID) *AgentsV2DeleteOne {
	builder := c.Delete().Where(agentsv2.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AgentsV2DeleteOne{builder}
}

// Query returns a query builder for AgentsV2.
func (c *AgentsV2Client) Query() *AgentsV2Query {
	return &AgentsV2Query{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAgentsV2},
		inters: c.Interceptors(),
	}
}

// Get returns a AgentsV2 entity by its id.
func (c *AgentsV2Client) Get(ctx context.Context, id uuid.UUID) (*AgentsV2, error) {
	return c.Query().Where(agentsv2.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AgentsV2Client) GetX(ctx context.Context, id uuid.UUID) *AgentsV2 {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AgentsV2Client) Hooks() []Hook {
	return c.hooks.AgentsV2
}

// Interceptors returns the client interceptors.
func (c *AgentsV2Client) Interceptors() []Interceptor {
	return c.inters.AgentsV2
}

func (c *AgentsV2Client) mutate(ctx context.Context, m *AgentsV2Mutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AgentsV2Create{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AgentsV2Update{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AgentsV2UpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AgentsV2Delete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AgentsV2 mutation op: %q", m.Op())
	}
}

// IntegrationTypeClient is a client for the IntegrationType schema.
type IntegrationTypeClient struct {
	config
}

// NewIntegrationTypeClient returns a client for the IntegrationType from the given config.
func NewIntegrationTypeClient(c config) *IntegrationTypeClient {
	return &IntegrationTypeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `integrationtype.Hooks(f(g(h())))`.
func (c *IntegrationTypeClient) Use(hooks ...Hook) {
	c.hooks.IntegrationType = append(c.hooks.IntegrationType, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `integrationtype.Intercept(f(g(h())))`.
func (c *IntegrationTypeClient) Intercept(interceptors ...Interceptor) {
	c.inters.IntegrationType = append(c.inters.IntegrationType, interceptors...)
}

// Create returns a builder for creating a IntegrationType entity.
func (c *IntegrationTypeClient) Create() *IntegrationTypeCreate {
	mutation := newIntegrationTypeMutation(c.config, OpCreate)
	return &IntegrationTypeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of IntegrationType entities.
func (c *IntegrationTypeClient) CreateBulk(builders ...*IntegrationTypeCreate) *IntegrationTypeCreateBulk {
	return &IntegrationTypeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *IntegrationTypeClient) MapCreateBulk(slice any, setFunc func(*IntegrationTypeCreate, int)) *IntegrationTypeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &IntegrationTypeCreateBulk{err: fmt.Errorf("calling to IntegrationTypeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*IntegrationTypeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &IntegrationTypeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for IntegrationType.
func (c *IntegrationTypeClient) Update() *IntegrationTypeUpdate {
	mutation := newIntegrationTypeMutation(c.config, OpUpdate)
	return &IntegrationTypeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IntegrationTypeClient) UpdateOne(it *IntegrationType) *IntegrationTypeUpdateOne {
	mutation := newIntegrationTypeMutation(c.config, OpUpdateOne, withIntegrationType(it))
	return &IntegrationTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IntegrationTypeClient) UpdateOneID(id string) *IntegrationTypeUpdateOne {
	mutation := newIntegrationTypeMutation(c.config, OpUpdateOne, withIntegrationTypeID(id))
	return &IntegrationTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for IntegrationType.
func (c *IntegrationTypeClient) Delete() *IntegrationTypeDelete {
	mutation := newIntegrationTypeMutation(c.config, OpDelete)
	return &IntegrationTypeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IntegrationTypeClient) DeleteOne(it *IntegrationType) *IntegrationTypeDeleteOne {
	return c.DeleteOneID(it.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IntegrationTypeClient) DeleteOneID(id string) *IntegrationTypeDeleteOne {
	builder := c.Delete().Where(integrationtype.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IntegrationTypeDeleteOne{builder}
}

// Query returns a query builder for IntegrationType.
func (c *IntegrationTypeClient) Query() *IntegrationTypeQuery {
	return &IntegrationTypeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeIntegrationType},
		inters: c.Interceptors(),
	}
}

// Get returns a IntegrationType entity by its id.
func (c *IntegrationTypeClient) Get(ctx context.Context, id string) (*IntegrationType, error) {
	return c.Query().Where(integrationtype.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IntegrationTypeClient) GetX(ctx context.Context, id string) *IntegrationType {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryIntegrations queries the integrations edge of a IntegrationType.
func (c *IntegrationTypeClient) QueryIntegrations(it *IntegrationType) *IntegrationsQuery {
	query := (&IntegrationsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := it.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(integrationtype.Table, integrationtype.FieldID, id),
			sqlgraph.To(integrations.Table, integrations.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, integrationtype.IntegrationsTable, integrationtype.IntegrationsColumn),
		)
		fromV = sqlgraph.Neighbors(it.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *IntegrationTypeClient) Hooks() []Hook {
	return c.hooks.IntegrationType
}

// Interceptors returns the client interceptors.
func (c *IntegrationTypeClient) Interceptors() []Interceptor {
	return c.inters.IntegrationType
}

func (c *IntegrationTypeClient) mutate(ctx context.Context, m *IntegrationTypeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IntegrationTypeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IntegrationTypeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IntegrationTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IntegrationTypeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown IntegrationType mutation op: %q", m.Op())
	}
}

// IntegrationsClient is a client for the Integrations schema.
type IntegrationsClient struct {
	config
}

// NewIntegrationsClient returns a client for the Integrations from the given config.
func NewIntegrationsClient(c config) *IntegrationsClient {
	return &IntegrationsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `integrations.Hooks(f(g(h())))`.
func (c *IntegrationsClient) Use(hooks ...Hook) {
	c.hooks.Integrations = append(c.hooks.Integrations, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `integrations.Intercept(f(g(h())))`.
func (c *IntegrationsClient) Intercept(interceptors ...Interceptor) {
	c.inters.Integrations = append(c.inters.Integrations, interceptors...)
}

// Create returns a builder for creating a Integrations entity.
func (c *IntegrationsClient) Create() *IntegrationsCreate {
	mutation := newIntegrationsMutation(c.config, OpCreate)
	return &IntegrationsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Integrations entities.
func (c *IntegrationsClient) CreateBulk(builders ...*IntegrationsCreate) *IntegrationsCreateBulk {
	return &IntegrationsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *IntegrationsClient) MapCreateBulk(slice any, setFunc func(*IntegrationsCreate, int)) *IntegrationsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &IntegrationsCreateBulk{err: fmt.Errorf("calling to IntegrationsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*IntegrationsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &IntegrationsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Integrations.
func (c *IntegrationsClient) Update() *IntegrationsUpdate {
	mutation := newIntegrationsMutation(c.config, OpUpdate)
	return &IntegrationsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IntegrationsClient) UpdateOne(i *Integrations) *IntegrationsUpdateOne {
	mutation := newIntegrationsMutation(c.config, OpUpdateOne, withIntegrations(i))
	return &IntegrationsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IntegrationsClient) UpdateOneID(id uuid.UUID) *IntegrationsUpdateOne {
	mutation := newIntegrationsMutation(c.config, OpUpdateOne, withIntegrationsID(id))
	return &IntegrationsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Integrations.
func (c *IntegrationsClient) Delete() *IntegrationsDelete {
	mutation := newIntegrationsMutation(c.config, OpDelete)
	return &IntegrationsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IntegrationsClient) DeleteOne(i *Integrations) *IntegrationsDeleteOne {
	return c.DeleteOneID(i.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IntegrationsClient) DeleteOneID(id uuid.UUID) *IntegrationsDeleteOne {
	builder := c.Delete().Where(integrations.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IntegrationsDeleteOne{builder}
}

// Query returns a query builder for Integrations.
func (c *IntegrationsClient) Query() *IntegrationsQuery {
	return &IntegrationsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeIntegrations},
		inters: c.Interceptors(),
	}
}

// Get returns a Integrations entity by its id.
func (c *IntegrationsClient) Get(ctx context.Context, id uuid.UUID) (*Integrations, error) {
	return c.Query().Where(integrations.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IntegrationsClient) GetX(ctx context.Context, id uuid.UUID) *Integrations {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryScans queries the scans edge of a Integrations.
func (c *IntegrationsClient) QueryScans(i *Integrations) *ScansQuery {
	query := (&ScansClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(integrations.Table, integrations.FieldID, id),
			sqlgraph.To(scans.Table, scans.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, integrations.ScansTable, integrations.ScansColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *IntegrationsClient) Hooks() []Hook {
	return c.hooks.Integrations
}

// Interceptors returns the client interceptors.
func (c *IntegrationsClient) Interceptors() []Interceptor {
	return c.inters.Integrations
}

func (c *IntegrationsClient) mutate(ctx context.Context, m *IntegrationsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IntegrationsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IntegrationsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IntegrationsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IntegrationsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Integrations mutation op: %q", m.Op())
	}
}

// PoliciesClient is a client for the Policies schema.
type PoliciesClient struct {
	config
}

// NewPoliciesClient returns a client for the Policies from the given config.
func NewPoliciesClient(c config) *PoliciesClient {
	return &PoliciesClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `policies.Hooks(f(g(h())))`.
func (c *PoliciesClient) Use(hooks ...Hook) {
	c.hooks.Policies = append(c.hooks.Policies, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `policies.Intercept(f(g(h())))`.
func (c *PoliciesClient) Intercept(interceptors ...Interceptor) {
	c.inters.Policies = append(c.inters.Policies, interceptors...)
}

// Create returns a builder for creating a Policies entity.
func (c *PoliciesClient) Create() *PoliciesCreate {
	mutation := newPoliciesMutation(c.config, OpCreate)
	return &PoliciesCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Policies entities.
func (c *PoliciesClient) CreateBulk(builders ...*PoliciesCreate) *PoliciesCreateBulk {
	return &PoliciesCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PoliciesClient) MapCreateBulk(slice any, setFunc func(*PoliciesCreate, int)) *PoliciesCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PoliciesCreateBulk{err: fmt.Errorf("calling to PoliciesClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PoliciesCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PoliciesCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Policies.
func (c *PoliciesClient) Update() *PoliciesUpdate {
	mutation := newPoliciesMutation(c.config, OpUpdate)
	return &PoliciesUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PoliciesClient) UpdateOne(po *Policies) *PoliciesUpdateOne {
	mutation := newPoliciesMutation(c.config, OpUpdateOne, withPolicies(po))
	return &PoliciesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PoliciesClient) UpdateOneID(id uuid.UUID) *PoliciesUpdateOne {
	mutation := newPoliciesMutation(c.config, OpUpdateOne, withPoliciesID(id))
	return &PoliciesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Policies.
func (c *PoliciesClient) Delete() *PoliciesDelete {
	mutation := newPoliciesMutation(c.config, OpDelete)
	return &PoliciesDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PoliciesClient) DeleteOne(po *Policies) *PoliciesDeleteOne {
	return c.DeleteOneID(po.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PoliciesClient) DeleteOneID(id uuid.UUID) *PoliciesDeleteOne {
	builder := c.Delete().Where(policies.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PoliciesDeleteOne{builder}
}

// Query returns a query builder for Policies.
func (c *PoliciesClient) Query() *PoliciesQuery {
	return &PoliciesQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePolicies},
		inters: c.Interceptors(),
	}
}

// Get returns a Policies entity by its id.
func (c *PoliciesClient) Get(ctx context.Context, id uuid.UUID) (*Policies, error) {
	return c.Query().Where(policies.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PoliciesClient) GetX(ctx context.Context, id uuid.UUID) *Policies {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPolicyLabels queries the policy_labels edge of a Policies.
func (c *PoliciesClient) QueryPolicyLabels(po *Policies) *PolicyLabelsQuery {
	query := (&PolicyLabelsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := po.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(policies.Table, policies.FieldID, id),
			sqlgraph.To(policylabels.Table, policylabels.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, policies.PolicyLabelsTable, policies.PolicyLabelsColumn),
		)
		fromV = sqlgraph.Neighbors(po.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryScans queries the scans edge of a Policies.
func (c *PoliciesClient) QueryScans(po *Policies) *ScansQuery {
	query := (&ScansClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := po.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(policies.Table, policies.FieldID, id),
			sqlgraph.To(scans.Table, scans.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, policies.ScansTable, policies.ScansColumn),
		)
		fromV = sqlgraph.Neighbors(po.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PoliciesClient) Hooks() []Hook {
	return c.hooks.Policies
}

// Interceptors returns the client interceptors.
func (c *PoliciesClient) Interceptors() []Interceptor {
	return c.inters.Policies
}

func (c *PoliciesClient) mutate(ctx context.Context, m *PoliciesMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PoliciesCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PoliciesUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PoliciesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PoliciesDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Policies mutation op: %q", m.Op())
	}
}

// PolicyLabelsClient is a client for the PolicyLabels schema.
type PolicyLabelsClient struct {
	config
}

// NewPolicyLabelsClient returns a client for the PolicyLabels from the given config.
func NewPolicyLabelsClient(c config) *PolicyLabelsClient {
	return &PolicyLabelsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `policylabels.Hooks(f(g(h())))`.
func (c *PolicyLabelsClient) Use(hooks ...Hook) {
	c.hooks.PolicyLabels = append(c.hooks.PolicyLabels, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `policylabels.Intercept(f(g(h())))`.
func (c *PolicyLabelsClient) Intercept(interceptors ...Interceptor) {
	c.inters.PolicyLabels = append(c.inters.PolicyLabels, interceptors...)
}

// Create returns a builder for creating a PolicyLabels entity.
func (c *PolicyLabelsClient) Create() *PolicyLabelsCreate {
	mutation := newPolicyLabelsMutation(c.config, OpCreate)
	return &PolicyLabelsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PolicyLabels entities.
func (c *PolicyLabelsClient) CreateBulk(builders ...*PolicyLabelsCreate) *PolicyLabelsCreateBulk {
	return &PolicyLabelsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PolicyLabelsClient) MapCreateBulk(slice any, setFunc func(*PolicyLabelsCreate, int)) *PolicyLabelsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PolicyLabelsCreateBulk{err: fmt.Errorf("calling to PolicyLabelsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PolicyLabelsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PolicyLabelsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PolicyLabels.
func (c *PolicyLabelsClient) Update() *PolicyLabelsUpdate {
	mutation := newPolicyLabelsMutation(c.config, OpUpdate)
	return &PolicyLabelsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PolicyLabelsClient) UpdateOne(pl *PolicyLabels) *PolicyLabelsUpdateOne {
	mutation := newPolicyLabelsMutation(c.config, OpUpdateOne, withPolicyLabels(pl))
	return &PolicyLabelsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PolicyLabelsClient) UpdateOneID(id int) *PolicyLabelsUpdateOne {
	mutation := newPolicyLabelsMutation(c.config, OpUpdateOne, withPolicyLabelsID(id))
	return &PolicyLabelsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PolicyLabels.
func (c *PolicyLabelsClient) Delete() *PolicyLabelsDelete {
	mutation := newPolicyLabelsMutation(c.config, OpDelete)
	return &PolicyLabelsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PolicyLabelsClient) DeleteOne(pl *PolicyLabels) *PolicyLabelsDeleteOne {
	return c.DeleteOneID(pl.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PolicyLabelsClient) DeleteOneID(id int) *PolicyLabelsDeleteOne {
	builder := c.Delete().Where(policylabels.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PolicyLabelsDeleteOne{builder}
}

// Query returns a query builder for PolicyLabels.
func (c *PolicyLabelsClient) Query() *PolicyLabelsQuery {
	return &PolicyLabelsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePolicyLabels},
		inters: c.Interceptors(),
	}
}

// Get returns a PolicyLabels entity by its id.
func (c *PolicyLabelsClient) Get(ctx context.Context, id int) (*PolicyLabels, error) {
	return c.Query().Where(policylabels.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PolicyLabelsClient) GetX(ctx context.Context, id int) *PolicyLabels {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPolicy queries the policy edge of a PolicyLabels.
func (c *PolicyLabelsClient) QueryPolicy(pl *PolicyLabels) *PoliciesQuery {
	query := (&PoliciesClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(policylabels.Table, policylabels.FieldID, id),
			sqlgraph.To(policies.Table, policies.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, policylabels.PolicyTable, policylabels.PolicyColumn),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PolicyLabelsClient) Hooks() []Hook {
	return c.hooks.PolicyLabels
}

// Interceptors returns the client interceptors.
func (c *PolicyLabelsClient) Interceptors() []Interceptor {
	return c.inters.PolicyLabels
}

func (c *PolicyLabelsClient) mutate(ctx context.Context, m *PolicyLabelsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PolicyLabelsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PolicyLabelsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PolicyLabelsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PolicyLabelsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PolicyLabels mutation op: %q", m.Op())
	}
}

// ScanLabelsClient is a client for the ScanLabels schema.
type ScanLabelsClient struct {
	config
}

// NewScanLabelsClient returns a client for the ScanLabels from the given config.
func NewScanLabelsClient(c config) *ScanLabelsClient {
	return &ScanLabelsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `scanlabels.Hooks(f(g(h())))`.
func (c *ScanLabelsClient) Use(hooks ...Hook) {
	c.hooks.ScanLabels = append(c.hooks.ScanLabels, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `scanlabels.Intercept(f(g(h())))`.
func (c *ScanLabelsClient) Intercept(interceptors ...Interceptor) {
	c.inters.ScanLabels = append(c.inters.ScanLabels, interceptors...)
}

// Create returns a builder for creating a ScanLabels entity.
func (c *ScanLabelsClient) Create() *ScanLabelsCreate {
	mutation := newScanLabelsMutation(c.config, OpCreate)
	return &ScanLabelsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ScanLabels entities.
func (c *ScanLabelsClient) CreateBulk(builders ...*ScanLabelsCreate) *ScanLabelsCreateBulk {
	return &ScanLabelsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ScanLabelsClient) MapCreateBulk(slice any, setFunc func(*ScanLabelsCreate, int)) *ScanLabelsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ScanLabelsCreateBulk{err: fmt.Errorf("calling to ScanLabelsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ScanLabelsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ScanLabelsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ScanLabels.
func (c *ScanLabelsClient) Update() *ScanLabelsUpdate {
	mutation := newScanLabelsMutation(c.config, OpUpdate)
	return &ScanLabelsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ScanLabelsClient) UpdateOne(sl *ScanLabels) *ScanLabelsUpdateOne {
	mutation := newScanLabelsMutation(c.config, OpUpdateOne, withScanLabels(sl))
	return &ScanLabelsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ScanLabelsClient) UpdateOneID(id int) *ScanLabelsUpdateOne {
	mutation := newScanLabelsMutation(c.config, OpUpdateOne, withScanLabelsID(id))
	return &ScanLabelsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ScanLabels.
func (c *ScanLabelsClient) Delete() *ScanLabelsDelete {
	mutation := newScanLabelsMutation(c.config, OpDelete)
	return &ScanLabelsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ScanLabelsClient) DeleteOne(sl *ScanLabels) *ScanLabelsDeleteOne {
	return c.DeleteOneID(sl.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ScanLabelsClient) DeleteOneID(id int) *ScanLabelsDeleteOne {
	builder := c.Delete().Where(scanlabels.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ScanLabelsDeleteOne{builder}
}

// Query returns a query builder for ScanLabels.
func (c *ScanLabelsClient) Query() *ScanLabelsQuery {
	return &ScanLabelsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeScanLabels},
		inters: c.Interceptors(),
	}
}

// Get returns a ScanLabels entity by its id.
func (c *ScanLabelsClient) Get(ctx context.Context, id int) (*ScanLabels, error) {
	return c.Query().Where(scanlabels.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ScanLabelsClient) GetX(ctx context.Context, id int) *ScanLabels {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryScan queries the scan edge of a ScanLabels.
func (c *ScanLabelsClient) QueryScan(sl *ScanLabels) *ScansQuery {
	query := (&ScansClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scanlabels.Table, scanlabels.FieldID, id),
			sqlgraph.To(scans.Table, scans.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, scanlabels.ScanTable, scanlabels.ScanColumn),
		)
		fromV = sqlgraph.Neighbors(sl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ScanLabelsClient) Hooks() []Hook {
	return c.hooks.ScanLabels
}

// Interceptors returns the client interceptors.
func (c *ScanLabelsClient) Interceptors() []Interceptor {
	return c.inters.ScanLabels
}

func (c *ScanLabelsClient) mutate(ctx context.Context, m *ScanLabelsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ScanLabelsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ScanLabelsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ScanLabelsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ScanLabelsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ScanLabels mutation op: %q", m.Op())
	}
}

// ScanNotifyClient is a client for the ScanNotify schema.
type ScanNotifyClient struct {
	config
}

// NewScanNotifyClient returns a client for the ScanNotify from the given config.
func NewScanNotifyClient(c config) *ScanNotifyClient {
	return &ScanNotifyClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `scannotify.Hooks(f(g(h())))`.
func (c *ScanNotifyClient) Use(hooks ...Hook) {
	c.hooks.ScanNotify = append(c.hooks.ScanNotify, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `scannotify.Intercept(f(g(h())))`.
func (c *ScanNotifyClient) Intercept(interceptors ...Interceptor) {
	c.inters.ScanNotify = append(c.inters.ScanNotify, interceptors...)
}

// Create returns a builder for creating a ScanNotify entity.
func (c *ScanNotifyClient) Create() *ScanNotifyCreate {
	mutation := newScanNotifyMutation(c.config, OpCreate)
	return &ScanNotifyCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ScanNotify entities.
func (c *ScanNotifyClient) CreateBulk(builders ...*ScanNotifyCreate) *ScanNotifyCreateBulk {
	return &ScanNotifyCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ScanNotifyClient) MapCreateBulk(slice any, setFunc func(*ScanNotifyCreate, int)) *ScanNotifyCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ScanNotifyCreateBulk{err: fmt.Errorf("calling to ScanNotifyClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ScanNotifyCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ScanNotifyCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ScanNotify.
func (c *ScanNotifyClient) Update() *ScanNotifyUpdate {
	mutation := newScanNotifyMutation(c.config, OpUpdate)
	return &ScanNotifyUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ScanNotifyClient) UpdateOne(sn *ScanNotify) *ScanNotifyUpdateOne {
	mutation := newScanNotifyMutation(c.config, OpUpdateOne, withScanNotify(sn))
	return &ScanNotifyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ScanNotifyClient) UpdateOneID(id uuid.UUID) *ScanNotifyUpdateOne {
	mutation := newScanNotifyMutation(c.config, OpUpdateOne, withScanNotifyID(id))
	return &ScanNotifyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ScanNotify.
func (c *ScanNotifyClient) Delete() *ScanNotifyDelete {
	mutation := newScanNotifyMutation(c.config, OpDelete)
	return &ScanNotifyDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ScanNotifyClient) DeleteOne(sn *ScanNotify) *ScanNotifyDeleteOne {
	return c.DeleteOneID(sn.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ScanNotifyClient) DeleteOneID(id uuid.UUID) *ScanNotifyDeleteOne {
	builder := c.Delete().Where(scannotify.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ScanNotifyDeleteOne{builder}
}

// Query returns a query builder for ScanNotify.
func (c *ScanNotifyClient) Query() *ScanNotifyQuery {
	return &ScanNotifyQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeScanNotify},
		inters: c.Interceptors(),
	}
}

// Get returns a ScanNotify entity by its id.
func (c *ScanNotifyClient) Get(ctx context.Context, id uuid.UUID) (*ScanNotify, error) {
	return c.Query().Where(scannotify.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ScanNotifyClient) GetX(ctx context.Context, id uuid.UUID) *ScanNotify {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryScan queries the scan edge of a ScanNotify.
func (c *ScanNotifyClient) QueryScan(sn *ScanNotify) *ScansQuery {
	query := (&ScansClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sn.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scannotify.Table, scannotify.FieldID, id),
			sqlgraph.To(scans.Table, scans.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, scannotify.ScanTable, scannotify.ScanColumn),
		)
		fromV = sqlgraph.Neighbors(sn.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ScanNotifyClient) Hooks() []Hook {
	return c.hooks.ScanNotify
}

// Interceptors returns the client interceptors.
func (c *ScanNotifyClient) Interceptors() []Interceptor {
	return c.inters.ScanNotify
}

func (c *ScanNotifyClient) mutate(ctx context.Context, m *ScanNotifyMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ScanNotifyCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ScanNotifyUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ScanNotifyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ScanNotifyDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ScanNotify mutation op: %q", m.Op())
	}
}

// ScansClient is a client for the Scans schema.
type ScansClient struct {
	config
}

// NewScansClient returns a client for the Scans from the given config.
func NewScansClient(c config) *ScansClient {
	return &ScansClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `scans.Hooks(f(g(h())))`.
func (c *ScansClient) Use(hooks ...Hook) {
	c.hooks.Scans = append(c.hooks.Scans, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `scans.Intercept(f(g(h())))`.
func (c *ScansClient) Intercept(interceptors ...Interceptor) {
	c.inters.Scans = append(c.inters.Scans, interceptors...)
}

// Create returns a builder for creating a Scans entity.
func (c *ScansClient) Create() *ScansCreate {
	mutation := newScansMutation(c.config, OpCreate)
	return &ScansCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Scans entities.
func (c *ScansClient) CreateBulk(builders ...*ScansCreate) *ScansCreateBulk {
	return &ScansCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ScansClient) MapCreateBulk(slice any, setFunc func(*ScansCreate, int)) *ScansCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ScansCreateBulk{err: fmt.Errorf("calling to ScansClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ScansCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ScansCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Scans.
func (c *ScansClient) Update() *ScansUpdate {
	mutation := newScansMutation(c.config, OpUpdate)
	return &ScansUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ScansClient) UpdateOne(s *Scans) *ScansUpdateOne {
	mutation := newScansMutation(c.config, OpUpdateOne, withScans(s))
	return &ScansUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ScansClient) UpdateOneID(id uuid.UUID) *ScansUpdateOne {
	mutation := newScansMutation(c.config, OpUpdateOne, withScansID(id))
	return &ScansUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Scans.
func (c *ScansClient) Delete() *ScansDelete {
	mutation := newScansMutation(c.config, OpDelete)
	return &ScansDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ScansClient) DeleteOne(s *Scans) *ScansDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ScansClient) DeleteOneID(id uuid.UUID) *ScansDeleteOne {
	builder := c.Delete().Where(scans.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ScansDeleteOne{builder}
}

// Query returns a query builder for Scans.
func (c *ScansClient) Query() *ScansQuery {
	return &ScansQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeScans},
		inters: c.Interceptors(),
	}
}

// Get returns a Scans entity by its id.
func (c *ScansClient) Get(ctx context.Context, id uuid.UUID) (*Scans, error) {
	return c.Query().Where(scans.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ScansClient) GetX(ctx context.Context, id uuid.UUID) *Scans {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPolicy queries the policy edge of a Scans.
func (c *ScansClient) QueryPolicy(s *Scans) *PoliciesQuery {
	query := (&PoliciesClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scans.Table, scans.FieldID, id),
			sqlgraph.To(policies.Table, policies.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, scans.PolicyTable, scans.PolicyColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIntegrations queries the integrations edge of a Scans.
func (c *ScansClient) QueryIntegrations(s *Scans) *IntegrationsQuery {
	query := (&IntegrationsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scans.Table, scans.FieldID, id),
			sqlgraph.To(integrations.Table, integrations.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, scans.IntegrationsTable, scans.IntegrationsColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryScanLabels queries the scan_labels edge of a Scans.
func (c *ScansClient) QueryScanLabels(s *Scans) *ScanLabelsQuery {
	query := (&ScanLabelsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scans.Table, scans.FieldID, id),
			sqlgraph.To(scanlabels.Table, scanlabels.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, scans.ScanLabelsTable, scans.ScanLabelsColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAgentTasks queries the agent_tasks edge of a Scans.
func (c *ScansClient) QueryAgentTasks(s *Scans) *AgentTasksQuery {
	query := (&AgentTasksClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scans.Table, scans.FieldID, id),
			sqlgraph.To(agenttasks.Table, agenttasks.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, scans.AgentTasksTable, scans.AgentTasksColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryScanNotifications queries the scan_notifications edge of a Scans.
func (c *ScansClient) QueryScanNotifications(s *Scans) *ScanNotifyQuery {
	query := (&ScanNotifyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scans.Table, scans.FieldID, id),
			sqlgraph.To(scannotify.Table, scannotify.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, scans.ScanNotificationsTable, scans.ScanNotificationsColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ScansClient) Hooks() []Hook {
	return c.hooks.Scans
}

// Interceptors returns the client interceptors.
func (c *ScansClient) Interceptors() []Interceptor {
	return c.inters.Scans
}

func (c *ScansClient) mutate(ctx context.Context, m *ScansMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ScansCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ScansUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ScansUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ScansDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Scans mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		AgentLabels, AgentTasks, Agents, AgentsV2, IntegrationType, Integrations,
		Policies, PolicyLabels, ScanLabels, ScanNotify, Scans []ent.Hook
	}
	inters struct {
		AgentLabels, AgentTasks, Agents, AgentsV2, IntegrationType, Integrations,
		Policies, PolicyLabels, ScanLabels, ScanNotify, Scans []ent.Interceptor
	}
)
